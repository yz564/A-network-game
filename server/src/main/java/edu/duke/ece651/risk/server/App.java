/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package edu.duke.ece651.risk.server;

//import static org.mockito.Answers.values;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

import edu.duke.ece651.risk.shared.ObjectIO;
import edu.duke.ece651.risk.shared.Territory;
import edu.duke.ece651.risk.shared.V1MapFactory;
import edu.duke.ece651.risk.shared.WorldMap;
import edu.duke.ece651.risk.shared.WorldMapFactory;

public class App {
  private ServerSocket listener;
  private WorldMapFactory factory;
  private BufferedReader stdIn;
  private int numPlayers;
  private volatile WorldMap theMap;
  private volatile ArrayList<Player> playerList;
  private volatile ArrayList<String> playerNames;
  private volatile HashSet<Integer> availableGroups;
  private ServerOrderHelper soh;

  public App(ServerSocket listener, WorldMapFactory factory, BufferedReader in) {
    this.listener = listener;
    this.factory = factory;
    this.stdIn = in;
    this.playerList = new ArrayList<Player>();
    this.playerNames = new ArrayList<String>();
    this.availableGroups = new HashSet<Integer>();
    this.soh = new ServerOrderHelper();
  }

  public void acceptConnections() throws IOException {
    System.out.println("Please set the player number:");
    this.numPlayers = Integer.parseInt(stdIn.readLine());
    this.theMap = factory.makeWorldMap(numPlayers);
    System.out.println("wait for players to join... " + "0/" + numPlayers);
    for (int i = 0; i < numPlayers; i++) {
      Socket client = listener.accept();
      System.out.println("New player connected... " + (i + 1) + "/" + numPlayers);
      String name = "Player " + (i + 1);
      playerNames.add(name);
      availableGroups.add(i + 1);
      Player p = new Player(client, i, name);
      playerList.add(p);
      Thread t = new Thread(p);
      t.start();
    }
  }

  public void doPlacement() throws Exception {
    for (int i = 0; i < numPlayers; i++) {
      Player p = playerList.get(i);
      HashMap<String, Territory> tlist = theMap.getPlayerTerritories(p.getName());
      int count = tlist.size();
      p.out.writeObject(new ObjectIO(Integer.toString(count)));
      p.out.flush();
      p.out.reset();
      for (String tname : tlist.keySet()) {
        Territory t = tlist.get(tname);
        if (count > 1) {
          ObjectIO m = new ObjectIO(p.getName() + " ,please add units on territory " + tname
              + " (available unit number: " + p.availableUnitNum + ")", p.availableUnitNum);
          p.out.writeObject(m);
          p.out.flush();
          p.out.reset();
          while (!p.isReady()) {
          }
          p.setNotReady();
          p.unitNum = Integer.parseInt(p.tmp.message);
          p.availableUnitNum -= p.unitNum;
          count--;
        } else {
          p.unitNum = p.availableUnitNum;
        }
        if (t.trySetNumUnits(p.unitNum)) {
          System.out.println(p.getName() + " placed " + p.unitNum + " on territory " + tname);
        }
      }
    }
  }

  public void doInitialization() throws Exception {
    for (int i = 0; i < numPlayers; i++) {
      Player p = playerList.get(i);
      ObjectIO m = new ObjectIO(p.getName() + " ,please select your territory groups: ", i, theMap, availableGroups);
      p.out.writeObject(m);
      p.out.flush();
      p.out.reset();
      while (!p.isReady()) {
      }
      if (theMap.tryAssignInitOwner(Integer.parseInt(p.tmp.message), p.getName())) {
        System.out.println(p.getName() + " selected group " + p.tmp.message);
      }
      availableGroups.remove(Integer.parseInt(p.tmp.message));
      p.setNotReady();
    }
    /*
    Player p = playerList.get(numPlayers-1);
    if (theMap.tryAssignInitOwner(availableGroups.iterator().next(), p.getName())) {
        System.out.println(p.getName() + " auto selected ");
      }
    */
  }

  public void doOneTurn() throws IOException {
    int readyNum = 0;
    for (int i = 0; i < numPlayers; i++) {
      Player p = playerList.get(i);
      HashMap<String, Territory> tlist = theMap.getPlayerTerritories(p.getName());
      if (tlist.size() == 0) {
        p.isEnd = true;
        p.ready = true;
      }
      if (!p.isEnd) {
        p.out.writeObject(new ObjectIO(p.getName(), i, theMap, playerNames));
        p.out.flush();
        p.out.reset();
        p.setNotReady();
      } else {
        p.out.writeObject(new ObjectIO(p.getName() + ", you are watching the game ", -1, theMap, playerNames));
        p.out.flush();
        p.out.reset();
      }
    }
    while (readyNum < numPlayers) {
      readyNum = 0;
      for (int i = 0; i < numPlayers; i++) {
        if (playerList.get(i).isReady()) {
          readyNum++;
        }
      }
    }
    for (int i = 0; i < numPlayers; i++) {
      soh.collectOrders(playerList.get(i).tmp);
    }
    System.out.println("Move Error: " + soh.tryResolveMoveOrders(theMap));
    System.out.println("Attack Error: " + soh.tryResolveAttackOrders(theMap));
    soh.clearAllOrders();
  }

  public void doRefresh() {
    for (int i = 0; i < numPlayers; i++) {
      Player p = playerList.get(i);
      if (!p.isEnd) {
        HashMap<String, Territory> tlist = theMap.getPlayerTerritories(p.getName());
        if (tlist.size() == 0) {
          p.isEnd = true;
          p.ready = true;
        } else {
          for (String tname : tlist.keySet()) {
            Territory t = tlist.get(tname);
            t.tryAddUnits(1);
            /*t.tryAddUnits(-2);
            if (t.getNumUnits() < 0) {
              t.tryAssignOwner("Player 1");
              }*/ //the setting is for quick check the game's result

          }
        }
      }
    }
  }

  public Boolean checkWinner() throws Exception {
    int count = 0;
    int winnerID = 0;
    for (int i = 0; i < numPlayers; i++) {
      Player p = playerList.get(i);
      if (!p.isEnd) {
        HashMap<String, Territory> tlist = theMap.getPlayerTerritories(p.getName());
        if (tlist.size() == 0) {
          p.isEnd = true;
          p.ready = true;
        } else {
          count++;
          winnerID=i;
        }
      }
    }

    if (count == 1) {
      String info = "Winner is " + playerList.get(winnerID).getName();
      System.out.println(info);
      for (int i = 0; i < numPlayers; i++) {
        Player p = playerList.get(i);
        if (i == winnerID) {
          p.out.writeObject(new ObjectIO(info, -3, theMap, playerNames));
        }
        else {
          p.out.writeObject(new ObjectIO(info, -2, theMap, playerNames));
        }
        p.out.flush();
        p.out.reset();
      }
      return true;
    }
    return false;
  }

  public static void main(String[] args) throws IOException {
    WorldMapFactory factory = new V1MapFactory();
    BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
    System.out.println("Please set the server port number: (default is 3333 by hitting Enter)");
    String tmp = input.readLine();
    int portNumber = 0;
    if (tmp.equals("")) {
      portNumber = 3333;
    } else {
      portNumber = Integer.parseInt(tmp);
    }
    try (var listener = new ServerSocket(portNumber)) {
      System.out.println("The server is running...");
      App game = new App(listener, factory, input);
      game.acceptConnections();// player threads are created at here
      game.doInitialization();
      game.doPlacement();
      System.out.println("Initialization finished");
      while (true) {
        game.doOneTurn();
        game.doRefresh();
        if (game.checkWinner()) {
          return;
        }
      }
    } catch (Exception e) {
    }
  }
}






